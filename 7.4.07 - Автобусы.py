'''

В автобусном парке ведется учет времени работы автобусов.
Для каждого автобуса фиксируются моменты отправления и прибытия в формате
часы, минуты и секунды. Нужно определить, сколько автобусов работали
одновременно в самый загруженный момент времени.

Входные данные:
В первой строке число N (1 ≤ N ≤ 1000) — количество автобусов.
Далее N строк, каждая содержит шесть целых чисел: часы, минуты и секунды
отправления, часы, минуты и секунды прибытия
(0 ≤ часы < 24, 0 ≤ минуты < 60, 0 ≤ секунды < 60).
Если время прибытия меньше времени отправления, считается, что автобус
работал с переходом через полночь.

Выходные данные:
Одно целое число — максимальное количество автобусов, работающих одновременно.

Sample Input 1:

3
8 00 00 9 00 00
8 30 00 10 00 00
9 15 00 11 00 00

Sample Output 1:

2

Sample Input 2:

2
23 50 00 0 10 00
0 05 00 1 00 00

Sample Output 2:

2

Sample Input 3:

4
6 00 00 7 00 00
7 00 01 8 00 00
8 00 01 9 00 00
9 00 01 10 00 00

Sample Output 3:

1

'''
# Считываем количество автобусов
n = int(input())

# Список для хранения событий: (время_в_секундах, тип_события)
# тип: +1 — начало работы, -1 — окончание
events = []


# Функция перевода времени в секунды
def time_to_seconds(h, m, s):
    return h * 3600 + m * 60 + s


# Обработка каждого автобуса
for _ in range(n):
    data = list(map(int, input().split()))
    h1, m1, s1, h2, m2, s2 = data
    start = time_to_seconds(h1, m1, s1)
    end = time_to_seconds(h2, m2, s2)

    if end < start:
        # Автобус работает через полночь
        events.append((start, 1))
        events.append((end + 24 * 3600, -1))
    else:
        # Автобус работает в пределах одних суток
        events.append((start, 1))
        events.append((end, -1))
        # Если начало до 12:00, добавляем копию на следующие сутки
        # чтобы учесть возможное пересечение с автобусами, идущими через полночь
        if start < 12 * 3600:  # до 12:00
            events.append((start + 24 * 3600, 1))
            events.append((end + 24 * 3600, -1))

# Сортировка событий по времени
# При равенстве времени: +1 (начало) идёт до -1 (окончание)
events.sort(key=lambda x: (x[0], -x[1]))

# Подсчёт максимального количества одновременно работающих автобусов
current_buses = 0
max_buses = 0
for time, event_type in events:
    current_buses += event_type
    if current_buses > max_buses:
        max_buses = current_buses

# Вывод результата
print(max_buses)