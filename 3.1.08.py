'''Для n пар скобок напишите функцию, которая генерирует все возможные
комбинации правильно сформированных скобок.'''

import math      # Импортируем модуль math для использования факториала
import random    # Импортируем random для перемешивания списка

def get_good_brackets(n):
    # n — удвоенное количество пар скобок

    # Пытаемся определить "количество перестановок" count = (2n)! / (n! * n!)
    a = math.factorial(2 * n)
    b = math.factorial(n)
    count = int(a / (b * b)) # делим на n! * n! потому что '(' и ')' повторяются по n раз
    # и перестановка каждой из них нового слова не дают
    numbers = list(range(1, n + 1))  # Создаём список [1, 2, 3, ..., n]
    # Он используется как "заглушка" для случайного назначения скобок

    tmp, result = [], []  # tmp — текущая последовательность скобок; result — список уникальных правильных последовательностей

    D = {'(': 1, ')': -1}  # Словарь для подсчёта баланса: '(' даёт +1, ')' даёт -1

    for _ in range(count):  # Повторяем count = n! раз
        random.shuffle(numbers)  # Перемешиваем список чисел [1..n] случайным образом
        tmp = []  # Очищаем временную последовательность
        balance = 0  # Счётчик баланса скобок

        # Назначаем скобки по чётности числа:
        for num in numbers:
            if num % 2 == 0:
                tmp.append(')')  # чётное число → закрывающая скобка
            else:
                tmp.append('(')  # нечётное число → открывающая скобка

        # Отсекаем последовательности, начинающиеся с ')'
        if tmp[0] == ')':
            continue  # не рассматриваем такие

        # Пытаемся "исправить" последовательность, если баланс стал отрицательным
        for i in range(n):
            balance += D[tmp[i]]  # обновляем баланс
            if balance < 0:  # если закрывающих скобок больше — нарушение
                # Ищем следующую '(' после текущей позиции
                try:
                    ind = tmp[(i + 1):].index('(')
                    # Меняем её местами с текущей ')'
                    tmp[i], tmp[ind + i + 1] = tmp[ind + i + 1], tmp[i]
                    balance += 2  # баланс улучшается: ')' → '(', значит +2
                except ValueError:
                    break  # если '(' нет — выходим

        # Добавляем только уникальные последовательности
        if tmp not in result:
            result.append(tmp)

    # Выводим результат
    for element in result:
        print(''.join(element))  # объединяем список символов в строку и выводим

get_good_brackets(2 * int(input()))