'''На вход подается размер двумерной матрицы m x n на одной строке через пробел,
затем на следующих строках подаются сами элементы матрицы. По матрице можно
перемещаться, из клетки можно уходить только в соседнюю по стороне клетку,
переходы по диагонали, а также выход за границу матрицы запрещены.
Ваша задача — найти наиболее длинный возрастающий путь в матрице.
Путь возрастающий, если значения в посещаемых клетках строго возрастают
от начала пути к его концу. В ответ нужно выводить длину такого пути.

Sample Input 1:

2 3
10 8 5
10 5 4
Sample Output 1:

4'''



def get_longest_path(matrix, m, n):
    '''Используется мемоизация (динамическое программирование),
    чтобы не пересчитывать путь из одной и той же клетки несколько раз.
    Алгоритм проходит по всем клеткам и запускает DFS-подобный обход с мемоизацией.
    '''
    # Проверка на случай пустой матрицы
    if m == 0 or n == 0:
        return 0

    # Создаём таблицу динамического программирования dp,
    # где dp[i][j] будет хранить длину самого длинного возрастающего пути,
    # начинающегося в клетке (i, j). Изначально все значения -1 — не посчитаны.
    dp = [[-1] * n for _ in range(m)]

    # Список возможных направлений движения: вверх, вниз, влево, вправо
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    # Внутренняя рекурсивная функция для вычисления максимального пути из клетки (i, j)
    def func(i, j):
        # Если значение уже посчитано — возвращаем его (мемоизация)
        if dp[i][j] != -1:
            return dp[i][j]

        # Минимальная длина пути — 1 (сама клетка)
        max_path = 1

        # Перебираем все 4 направления
        for di, dj in directions:
            ni, nj = i + di, j + dj  # координаты соседней клетки

            # Проверяем, что соседняя клетка в пределах матрицы
            # и её значение строго больше текущего
            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                # Рекурсивно вычисляем длину пути из соседа
                # и обновляем максимальную длину
                length = 1 + func(ni, nj)
                max_path = max(max_path, length)

        # Сохраняем результат в dp для избежания повторных вычислений
        dp[i][j] = max_path
        return max_path

    # Перебираем все клетки матрицы и находим максимальный путь
    result = 1
    for i in range(m):
        for j in range(n):
            result = max(result, func(i, j))

    # Возвращаем длину самого длинного возрастающего пути
    return result


# Считываем размеры матрицы m (строки) и n (столбцы)
m, n = list(map(int, input().split()))

# Считываем саму матрицу построчно
matrix = []

for i in range(m):
    # Каждую строку разбиваем на числа и добавляем в матрицу
    row = list(map(int, input().split()))
    matrix.append(row)

# Запускаем функцию и выводим результат
print(get_longest_path(matrix, m, n))