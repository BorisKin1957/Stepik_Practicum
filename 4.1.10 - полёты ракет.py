'''Некоторая известная компания идёт в ногу со временем — с началом активных
космических перелётов в компании открылся сервис межпланетного такси:
пользователю необходимо лишь указать координаты начала и конца перелёта,
после чего за ним вылетит персональная ракета.

По сути, любой заказ можно описать в виде событий четырёх типов:

A (accepted) — заказ принят в работу (ракета вылетела за клиентом);

B (boarding) — клиент сел в ракету;

S (success) — заказ успешно завершён (клиент вышел на планете назначения);

C (cancelled) — заказ отменён.

Все происходящие с ракетами события отправляются на сервера, где сразу логируются.
Вот только из-за проблем со связью (метеоритные потоки, вспышки на звездах и т.д.)
отправка событий иногда затягивается, из-за чего записи в получившемся логе
могут идти не по порядку.

Гарантируется, что все описанные в логе события задают один из следующих сценариев:

A - B - S

A - B - C

A - C

Вам, как главному аналитику (и по совместительству главному программисту)
ракетопарка, необходимо исследовать лог за прошедший год и определить для
каждой ракеты суммарное время движения (в минутах) в течение заказов.

В каждый момент времени ракета выполняет только один заказ. Будем считать,
что каждая ракета в каждый момент времени:

или стоит на месте в ожидании заказа,

или перемещается по космосу, выполняя заказ.

Движение начинается после принятия заказа и завершается после отмены или
завершения заказа. За одну минуту не может произойти несколько событий,
связанных с одной и той же ракетой.

В первой строке дано целое число — количество записей в логе.

Следующие N строк содержат записи в логе в формате dayhourminuteidstatus:

day (1 ≤ d ≤ 365) — номер дня (сквозная нумерация с начала календарного года);

hour (0 ≤ h < 24) — часы;

minute (0 ≤ m < 60) — минуты;

id (0 ≤ id ≤ 10^9) — уникальный идентификатор ракеты;

status ∈ {A, B, S, C} — буква, обозначающая тип события.

В ответ выведите на одной строке через пробел суммарное время движения на заказах
для каждой упомянутой в логе ракеты. Данные необходимо выводить в порядке
возрастания идентификаторов ракет.

Sample Input:

8
50 7 25 3632 A
14 23 52 212372 S
15 0 5 3632 C
14 21 30 212372 A
50 7 26 3632 C
14 21 30 3632 A
14 21 40 212372 B
14 23 52 3632 B
Sample Output:

156 142'''

# Подключаем библиотеки для работы с датами и временем
from datetime import datetime, timedelta

# Устанавливаем произвольный год, чтобы можно было работать с датами.
year = 2025

# Читаем количество строк в логе
n = int(input())

# Считываем все строки лога и разбиваем их по пробелам
base = [input().split() for _ in range(n)]

# Удаляем из рассмотрения строки, как не оказывающие влияния на результат
# Событие 'B' не влияет на длительность движения — ракета уже "движется" с момента 'A'
base = list(filter(lambda log: log[-1] != 'B', base))

# Сортируем лог по: идентификатору ракеты, затем по дате (день, час, минута)
base = sorted(base, key=lambda x: [int(x[3]), int(x[0]), int(x[1]), int(x[2])])

# Создаём список всех id ракет (в порядке после фильтрации и сортировки)
all_ids = list(map(lambda x: int(x[3]), base))

# Обрабатываем каждую ракету по её id
for id_num in sorted(set(all_ids)):
    result = 0 # Счётчик суммарного времени "движения" (в минутах)

    # Фильтруем записи только для текущей ракеты
    base_name = list(filter(lambda x: int(x[3]) == id_num, base))

    for i in range(len(base_name)):

        # Если это событие 'A'
        if int(base_name[i][3]) == id_num and base_name[i][4] == 'A':

            # То это начало события — фиксируем время начала "движения"
            start = datetime(year, 1, 1) + timedelta(days=int(base_name[i][0]), hours=int(base_name[i][1]), minutes=int(base_name[i][2]))
            continue # возвращаемся в начало циклаБ так как время старта зафиксировано

        # Если это событие 'C' или 'S' — завершаем текущий заказ,
        if int(base_name[i][3]) == id_num and (base_name[i][4] == 'C' or base_name[i][4] == 'S'):
            # Это конец события — фиксируем время завершения движения
            end = datetime(year, 1, 1) + timedelta(days=int(base_name[i][0]), hours=int(base_name[i][1]), minutes=int(base_name[i][2]))

        # Вычисляем длительность текущего движения
        duration = end - start

        # Преобразуем длительность в минуты (как дробное число)
        duration_in_minutes = duration.total_seconds() / 60

        # Вычисляем суммарную длительность движения
        result += duration_in_minutes

        # Сбрасываем start, end, чтобы не использовать повторно
        start, end = 0, 0

    # Выводим результат для текущей ракеты
    print(int(result), end=' ')
