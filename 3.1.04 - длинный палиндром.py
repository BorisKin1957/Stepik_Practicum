def get_longest_palindrome(s):
    """
    Находит самую длинную подстроку-палиндром в строке s.
    Подход: расширение из центра.
    Палиндром может быть:
        - нечётной длины (центр — один символ)
        - чётной длины (центр — между двумя символами)
    """

    start = 0  # Начало самой длинной палиндромной подстроки
    end = 0    # Конец (включительно)

    # Проходим по каждому возможному центру
    for i in range(len(s) - 1):
        # Проверяем палиндром с центром в i (нечётная длина)
        len1 = get_long(s, i, i)

        # Проверяем палиндром с центром между i и i+1 (чётная длина)
        len2 = get_long(s, i, i + 1)

        # Берём максимальную длину из двух
        max_len = max(len1, len2)

        # Если нашли палиндром длиннее текущего
        if max_len > (end - start + 1):
            # Обновляем границы
            start = i - (max_len - 1) // 2  # Центр минус половина длины
            end = i + max_len // 2         # Центр плюс половина длины

    return s[start:end + 1]  # Возвращаем саму подстроку


def get_long(s, left, right):
    """
    Вспомогательная функция.
    Расширяет палиндром от центра (left, right) в обе стороны,
    пока символы совпадают и индексы в пределах строки.
    Возвращает длину найденного палиндрома.
    """
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1   # Двигаемся влево
        right += 1  # Двигаемся вправо

    # После выхода из цикла:
    # left и right указывают на символы за пределами палиндрома
    # Поэтому длина = (right - 1) - (left + 1) + 1 = right - left - 1
    return right - left - 1


# Считываем строку и выводим результат
print(get_longest_palindrome(input()))