'''

На вход подается размер массива N и на отдельной строке, разделенные пробелом, сами элементы массива. В этой задаче вы будете перекладывать камни. Изначально есть N кучек камней. Кучка i весит a[i] килограммов. Кучки можно объединять. При объединении кучек i и j затрачивается a[i]+a[j] единиц энергии, при этом две исходные кучки пропадают и появляется кучка весом a[i]+a[j]. Определите наименьшее количество энергии, которое надо затратить для объединения всех кучек в одну.  Выведите единственное число — минимальную энергию, которую надо затратить на объединение всех кучек. Дополнительным условием будет временная сложность для алгоритма - O(NlogN)

Sample Input 1:

2
2 6

Sample Output 1:

8

Sample Input 2:

3
6 2 4

Sample Output 2:

18

Sample Input 3:

100
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51
  52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75
   76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98
   99 100

Sample Output 3:

32298

'''

'''
Решение с сортировкой. 

# Считываем количество кучек камней
n = int(input())

# Считываем веса кучек, разделяя строку по пробелам и преобразуя в список целых чисел
numbers = list(map(int, input().split()))

# Переменная для накопления общего количества затраченной энергии
result = 0

# Повторяем, пока не останется одна кучка
while len(numbers) > 1:
    energy = 0  # Временная переменная для хранения энергии, затраченной на текущее объединение
    numbers = sorted(numbers)  # Сортируем список по возрастанию, чтобы взять две самые маленькие кучки
    energy += (numbers[0] + numbers[1])  # Затрачиваем энергию, равную сумме двух наименьших кучек
    result += energy  # Добавляем затраченную энергию к общему результату
    numbers = numbers[2:]  # Удаляем две наименьшие кучки из списка
    numbers.append(energy)  # Добавляем новую кучку, полученную при объединении

# Выводим минимальную суммарную энергию, необходимую для объединения всех кучек в одну
print(result)


Сортировка на каждом шаге даёт O(N log N) на итерацию, а итераций O(N), итого: 
O(N² log N) — это больше, чем требуется по условию O(N log N).'''

'''В  удовлетворение требования:  временная сложность для алгоритма - O(NlogN) 
используем мин-кучу (бинарную кучу) — heapq, чтобы извлекать и добавлять 
элементы за O(log N).'''
import heapq

# Считываем количество кучек камней
n = int(input())

# Считываем веса кучек, разделяя строку по пробелам и преобразуя в список целых чисел
numbers = list(map(int, input().split()))

# Преобразуем список в мин-кучу
heapq.heapify(numbers)

# Переменная для накопления общего количества затраченной энергии
result = 0

# Пока в куче больше одного элемента
while len(numbers) > 1:
    # Извлекаем две наименьшие кучки
    a = heapq.heappop(numbers)
    b = heapq.heappop(numbers)
    # Объединяем, затрачивая энергию
    energy = a + b
    result += energy
    # Добавляем новую кучку обратно в кучу
    heapq.heappush(numbers, energy)

print(result)