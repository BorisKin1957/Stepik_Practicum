'''На вход подается количество элементов массива и сами элементы на отдельной
строке, разделенные пробелом. Найдите число таких пар элементов (a[i],a[j]),
где ∣a[i]−a[j]∣ % 200 == 0 и i < j. В ответ выводите количество пар,
подходящих под указанное выше условие.

Обязательным условием для задачи является реализация алгоритма с временной
сложность не выше О(N). К сожалению на платформе нельзя запускать очень
большие тестовые данные, поэтому пройдет решение с любой сложностью.

Sample Input 4:

100
4821 7365 159 2847 6503 9142 378 5216 8934 1470 3298 6751 8023 456 2390 5874
913 7468 3025 8619 1245 6983 4357 9720 361 7842 509 2576 9401 623 8154 3789
542 1967 8305 429 7581 2049 673 9156 3482 791 5604 1823 6397 407 8521 2956
718 9640 831 4765 2098 653 9274 3810 547 8923 1645 730 5189 276 9432 601 8574
319 7845 1026 459 8732 6071 294 9358 421 7680 153 8492 536 917 2640 683 9521
4078 615 8392 174 5963 280 7415 903 6284 357 8941 206 5739 820 4615 739 9852
314 6708 429 7531 186 5924 307 8649 512 9783

Sample Output 4:

24

'''

'''вместо сравнения разности, будем использовать остатки по модулю 200, потому что:

|a[i] - a[j]| % 200 == 0 <--> a[i] % 200 == a[j] % 200

Потому что если два числа дают одинаковый остаток при делении на 200, 
их разность делится на 200. А модуль тут не мешает — разность по модулю 200 
зависит только от остатков.

Стало быть, задача сводится к: посчитать количество пар индексов (i, j), 
где i < j и a[i] % 200 == a[j] % 200.'''

n = int(input())

# Срез numbers[:n] введен в код, так как test_4 содержит более 100 заявленных в n чисел
numbers = list(map(int, input().split()))[:n]


# Считаем количество чисел с каждым остатком по модулю 200
# Когда мы делим любое целое число на 200, возможные остатки — это: 0, 1, 2, ... 199
# поэтому:
count = [0] * 200

for num in numbers:
    remainder = num % 200
    count[remainder] += 1

# Для каждого остатка: количество пар = C(k, 2) = k * (k - 1) // 2
result = 0
for k in count:
    if k >= 2:
        result += k * (k - 1) // 2

print(result)