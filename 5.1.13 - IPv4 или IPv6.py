'''

На вход подается строка, состоящая из латинских букв, цифр и символов точки и
двоеточия. В этой задаче вам предстоит ответить на вопрос, является данная на
вход строка корректным IPv4 или IPv6-адресом. Решите задачу без использования
регулярных выражений. Валидный IPv4-адрес имеет следующий формат: s1.s2.s3.s4,
где si — целое число от 0 до 255. Числа si не должны иметь лидирующих нулей.
Валидный IPv6-адрес имеет следующий формат: s1:s2:s3:s4:s5:s6:s7:s8, где si -
представление числа в 16-ричной системе, состоящее не более чем из четырёх
символов. В записи каждого числа могут присутствовать лидирующие нули.
Разрешено использовать символы 0-9, a-f, A-F. si не может быть пустой
последовательностью символов. Выведите «IPv4», если строка является корректным
IPv4-адресом. Выведите «IPv6», если строка является корректным IPv6-адресом.
Выведите «Error», если строка не является корректной записью IP-адреса.

Замечание: в реальности в IPv6-адресе допустима замена группы нулевых полей на ::,
однако для простоты в данной задаче такое правило учитывать не нужно.'''

# Функция проверки корректности IPv4-адреса
def get_valid_ipv4(ip: str) -> str:
    # Разбиваем строку по точкам
    ip_lst = ip.split('.')
    # Присваиваем каждую часть отдельной переменной (s1, s2 и т.д.)
    s1 = ip_lst[0]
    s2 = ip_lst[1]
    s3 = ip_lst[2]
    s4 = ip_lst[3]

    # Проверяем каждую часть с помощью функции get_valid_s_ipv4
    # Если хотя бы одна часть некорректна (возвращает True), возвращаем 'Error'
    if (get_valid_s_ipv4(s1) or get_valid_s_ipv4(s2) or
            get_valid_s_ipv4(s3) or get_valid_s_ipv4(s4)):
        return 'Error'
    # Если все части корректны, возвращаем 'IPv4'
    return 'IPv4'


# Функция проверки корректности одной части IPv4 (например, "192")
def get_valid_s_ipv4(si: str) -> str:
    # Проверяем:
    # - не состоит ли из нецифровых символов
    # - длина больше 3 (например, "999" — максимум)
    # - значение больше 255
    # - есть ли лидирующий ноль (например, "01")
    # - пустая ли строка
    if (not si.isdigit() or len(si) > 3 or int(si) > 255
            or (len(si) > 1 and si[0] == '0') or si == ''):
        return True  # означает ошибку
    return False  # означает, что часть корректна


# Функция проверки одной части IPv6 (например, "1a2f")
def get_valid_s_ipv6(si: str) -> str:
    # Список допустимых символов в шестнадцатеричной системе
    good_char = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f']
    flag = False  # флаг для проверки наличия недопустимого символа

    # Проверяем каждый символ в части
    for char in si:
        if char.lower() not in good_char:  # если символ не в списке допустимых
            flag = True  # помечаем как ошибку
            break  # выходим из цикла

    # Проверяем:
    # - есть ли недопустимый символ (flag == True)
    # - длина больше 4 (например, "1a2b" — допустимо, "1a2b3" — нет)
    # - пустая ли строка
    if flag or len(si) > 4 or si == '':
        return True  # ошибка
    return False  # корректно


# Функция проверки корректности IPv6-адреса
def get_valid_ipv6(ip: str) -> str:
    # Разбиваем строку по двоеточиям
    ip_lst = ip.split(':')
    # Присваиваем каждую из 8 частей отдельной переменной
    s1 = ip_lst[0]
    s2 = ip_lst[1]
    s3 = ip_lst[2]
    s4 = ip_lst[3]
    s5 = ip_lst[4]
    s6 = ip_lst[5]
    s7 = ip_lst[6]
    s8 = ip_lst[7]

    # Проверяем каждую часть с помощью get_valid_s_ipv6
    # Если хотя бы одна часть некорректна, возвращаем 'Error'
    if (get_valid_s_ipv6(s1) or get_valid_s_ipv6(s2) or get_valid_s_ipv6(s3) or
            get_valid_s_ipv6(s4) or get_valid_s_ipv6(s5) or get_valid_s_ipv6(s6)
            or get_valid_s_ipv6(s7) or get_valid_s_ipv6(s8)):
        return 'Error'
    # Если всё корректно, возвращаем 'IPv6'
    return 'IPv6'


# Считываем входную строку
ip = input()

# Проверяем, сколько частей после разбиения по точкам
if len(ip.split('.')) == 4:
    # Если ровно 4 — возможно, это IPv4
    print(get_valid_ipv4(ip))

# Проверяем, сколько частей после разбиения по двоеточиям
elif len(ip.split(':')) == 8:
    # Если ровно 8 — возможно, это IPv6
    print(get_valid_ipv6(ip))
else:
    # Если ни 4, ни 8 — некорректный формат
    print('Error')