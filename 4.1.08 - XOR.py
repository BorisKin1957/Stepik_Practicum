'''Дан массив nums из n целых неотрицательных чисел и целое положительное число k.
За одну операцию можно выбрать индекс i и номер разряда b (b >= 0) и инвертировать
бит b в двоичной записи числа nums[i] (заменить 0 на 1 или 1 на 0).
Эквивалентно: nums[i] := nums[i] XOR (1 << b).

Требуется выполнить минимальное число операций так, чтобы:

nums[0] XOR nums[1] XOR ... XOR nums[n-1] = k.

Входные данные

Сначала задано число n, затем n целых чисел массива, далее - целое положительное число k.

Выходные данные

Выведите одно целое число - минимальное количество операций, необходимое,
чтобы XOR всех элементов массива стал равен k.

Sample Input 1:

4
2 1 3 4
1
Sample Output 1:

2
Sample Input 2:

4
2 0 2 0
0
Sample Output 2:

0'''

_ = input() # данное избыточно
nums = map(int, input().split())
k = int(input())
xor = 0  # Начинаем с 0: потому что x ^ 0 = x

for num in nums:
    xor ^= num # XOR — это побитовая операция: 1, если биты разные, 0, если одинаковые.
# Каждое изменение одного бита в любом числе — меняет один бит в общем XOR.
# Поэтому: Минимальное число операций = сколько битов отличаются у текущего XOR и у k
# Вычисляем, в каких битах текущий XOR отличается от k
diff = xor ^ k

# Подсчитываем количество единиц в двоичной записи diff — это и есть минимальное число операций
result = bin(diff).count('1')

print(result)